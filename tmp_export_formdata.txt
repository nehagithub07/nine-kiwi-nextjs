 
const S = (v: unknown) => (v == null ? "" : String(v).trim());

// Resolve coordinates from form: prefer explicit lat/lon; otherwise geocode from address
async function resolveCoords(form: FormData): Promise<{ lat: number; lon: number } | null> {
  const latNum = Number((form as any)?.lat);
  const lonNum = Number((form as any)?.lon);
  if (Number.isFinite(latNum) && Number.isFinite(lonNum)) {
    return { lat: latNum, lon: lonNum };
  }

  const addr = [form.streetAddress,
    [form.city, form.state].filter(Boolean).join(", "),
    [form.country, form.zipCode].filter(Boolean).join(" "),
  ].filter(Boolean).map(S).filter(Boolean).join(", ") || S(form.location);

  if (!addr) return null;
  // Prefer our server geocode route to avoid client-side CORS and rate limits
  try {
    const r = await fetch(`/api/geocode?q=${encodeURIComponent(addr)}`, { cache: 'no-store' });
    if (r.ok) {
      const j = await r.json();
      const lat = Number(j?.lat);
      const lon = Number(j?.lon);
      if (Number.isFinite(lat) && Number.isFinite(lon)) return { lat, lon };
    }
  } catch {}
  // Fallback to direct providers if route not available
  try {
    const r = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(addr)}&count=1`, { headers: { 'Accept-Language': 'en' }, cache: 'no-store' });
    if (r.ok) {
      const j = await r.json();
      const first = j?.results?.[0];
      const lat = Number(first?.latitude);
      const lon = Number(first?.longitude);
      if (Number.isFinite(lat) && Number.isFinite(lon)) return { lat, lon };
    }
  } catch {}
  try {
    const r = await fetch(`https://nominatim.openstreetmap.org/search?format=json&limit=1&q=${encodeURIComponent(addr)}`, { headers: { 'Accept-Language': 'en' }, cache: 'no-store' });
    if (r.ok) {
      const arr = await r.json();
      const first = Array.isArray(arr) ? arr[0] : null;
      const lat = Number(first?.lat);
      const lon = Number(first?.lon);
      if (Number.isFinite(lat) && Number.isFinite(lon)) return { lat, lon };
    }
  } catch {}
  return null;
}

// Build static map photo (Google Static Maps if key present, else OSM staticmap)
async function buildSiteMapFromForm(form: FormData): Promise<PhotoData | undefined> {
  try {
    const coords = await resolveCoords(form);
    if (!coords) return undefined;
    const gkey = (process.env.NEXT_PUBLIC_GOOGLE_STATIC_MAPS_KEY || '').trim();
    const url = gkey
      ? `https://maps.googleapis.com/maps/api/staticmap?center=${coords.lat},${coords.lon}&zoom=15&size=1200x600&scale=2&maptype=roadmap&markers=color:green|${coords.lat},${coords.lon}&key=${gkey}`
      : `https://staticmap.openstreetmap.de/staticmap.php?center=${coords.lat},${coords.lon}&zoom=15&size=1200x600&markers=${coords.lat},${coords.lon},lightgreen-pushpin`;
    let data = '';
    try { data = await fetchToDataURL(url); } catch {}
    const photo: PhotoData = {
      name: 'Site Map',
      data: data || url,
      caption: 'Site location map',
      description: '',
    };
    return photo;
  } catch { return undefined; }
}

// format "HH:mm" -> "12:00 PM"
function formatTime12(t?: string): string {
  if (!t) return "";
  try {
    const d = new Date(`2000-01-01T${t}`);
    return d.toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit", hour12: true });
  } catch {
    return t;
  }
}

const joinAddress = (form: FormData): string => {
  const parts = [
    form.streetAddress,
    [form.city, form.state].filter(Boolean).join(", "),
    [form.country, form.zipCode].filter(Boolean).join(" "),
  ].filter(Boolean).map(S).filter(Boolean);
  return parts.join(", ");
};

const headerText = (form: FormData): string => {
  const addr = joinAddress(form) || S(form.location);
  const purpose = S((form as any).purposeOfFieldVisit);
  const base = purpose || "Inspection Report";
  return [base, addr].filter(Boolean).join(" ");
};

const coverReportTitle = (form: FormData): string => {
  const purpose = S((form as any).purposeOfFieldVisit);
